#!/usr/bin/env python

# Copyright (c) 2019 Computer Vision Center (CVC) at the Universitat Autonoma de
# Barcelona (UAB).
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

from queue import Queue
import random
import pdb
import glob
from importlib.resources import path
import os
import time
import queue
import sys
from turtle import distance
from cv2 import transform
import numpy as np
import matplotlib.pyplot as plt
import cv2
import traceback
import matplotlib.pyplot as plt

import pandas as pd
print(sys.version_info.major, sys.version_info.minor)
try:
    sys.path.append(glob.glob('PythonAPI/carla/dist/carla-*%d.%d-%s.egg' % (
        sys.version_info.major,
        sys.version_info.minor,
        'win-amd64' if os.name == 'nt' else 'linux-x86_64'))[0])
except IndexError:
    pass
import carla

def visualize_image(image):
    # shape is (image.height * image.width * 4,)
    data = np.array(image.raw_data)
    data_reshaped = np.reshape(data, (image.height, image.width, 4))
    rgb_3channels = data_reshaped[:, :, :3]  # first 3 channels

    cv2.imshow("image", rgb_3channels)
    cv2.waitKey(10)

def draw_waypoints(waypoints, road_id=None, life_time=50.0):
    try:
        for waypoint in waypoints:

            if(waypoint.road_id == road_id):
                carla.DebugHelper.draw_string(waypoint.transform.location, 'O', draw_shadow=False,
                                    color=carla.Color(r=0, g=255, b=0), life_time=life_time,
                                    persistent_lines=True)
    except: 
        print(traceback.format_exc())

def main():
    ts = str(time.time())
    try:
        path_to_steer = pd.read_csv("_out/curve_to_steering.csv", usecols=["path", "steer", "throttle"])
    except:
        path_to_steer = pd.DataFrame()

    actor_list = []

    # In this tutorial script, we are going to add a vehicle to the simulation
    # and let it drive in autopilot. We will also create a camera attached to
    # that vehicle, and save all the images generated by the camera to disk.

    try:
        # First of all, we need to create the client that will send the requests
        # to the simulator. Here we'll assume the simulator is accepting
        # requests in the localhost at port 2000.
        client = carla.Client('localhost', 2000)
        client.set_timeout(30.0)
        # pdb.set_trace()
        print("Test")
        # Print the possible Towns we have available

        # Once we have a client we can retrieve the world that is currently
        # running.
        # map = random.choice(client.get_available_maps())
        map = "/Game/Carla/Maps/Town02"
        world = client.load_world(map)
        
        settings = world.get_settings()
        settings.synchronous_mode = True
        settings.fixed_delta_seconds = 0.05
        world.apply_settings(settings)
        print("Test")

        tm = client.get_trafficmanager()
        tm.set_synchronous_mode(True)
        print("Test")
        # world = client.get_world()
        # world = client.load_world(map)

        # The world contains the list blueprints that we can use for adding new
        # actors into the simulation.
        blueprint_library = world.get_blueprint_library()

        # Now let's filter all the blueprints of type 'vehicle' and choose one
        # at random.
        bp = blueprint_library.find("vehicle.audi.etron")
        # A blueprint contains the list of attributes that define a vehicle's
        # instance, we can read them and modify some of them. For instance,
        # let's randomize its color.
        if bp.has_attribute('color'):
            color = random.choice(bp.get_attribute('color').recommended_values)
            bp.set_attribute('color', color)

        # Now we need to give an initial transform to the vehicle. We choose a
        # random transform from the list of recommended spawn points of the map.
        #transform = random.choice(world.get_map().get_spawn_points())
        # Always fix the starting position

        # spawn = random.randrange(len(world.get_map().get_spawn_points()))
        
        
        spawns = world.get_map().get_spawn_points()
        spawn = random.choice(spawns)
        print("X: ", spawn.location.x)
        print("Y: ", spawn.location.y)
        transform = spawn # random.choice(spawns)
        #transform.location.y = 20

        print(map, spawn)
        # pdb.set_trace()

        # So let's tell the world to spawn the vehicle.
        vehicle = world.spawn_actor(bp, transform)

        # It is important to note that the actors we create won't be destroyed
        # unless we call their "destroy" function. If we fail to call "destroy"
        # they will stay in the simulation even after we quit the Python script.
        # For that reason, we are storing all the actors we create so we can
        # destroy them afterwards.
        actor_list.append(vehicle)
        print('created %s' % vehicle.type_id)

        

        # Let's add now a "depth" camera attached to the vehicle. Note that the
        # transform we give here is now relative to the vehicle.
        camera_bp = blueprint_library.find('sensor.camera.depth')
        camera_bp.set_attribute('image_size_x',  str(640))
        camera_bp.set_attribute('image_size_y',  str(320))
        camera_transform = carla.Transform(carla.Location(x=1.5, z=2.4))
        camera = world.spawn_actor(
            camera_bp, camera_transform, attach_to=vehicle)
        actor_list.append(camera)
        print('created %s' % camera.type_id)

        frame = 0

        # check if dir is already there
        if not os.path.isdir("_out/%s-%s/%s" % (map.split('/')[-1], spawn, ts)):
            os.makedirs("_out/%s-%s/%s" % (map.split('/')[-1], spawn, ts))


        # Now we register the function that will be called each time the sensor
        # receives an image. In this example we are saving the image to disk
        # converting the pixels to gray-scale.
        depth_image_queue = queue.Queue()
        cc = carla.ColorConverter.LogarithmicDepth
        # camera.listen(lambda image: image.save_to_disk('_out/%s-%s/depth-%d.png' % (map.split('/')[-1], spawn, frame), cc) if frame>10 else None)
        camera.listen(depth_image_queue.put)

        # also get and save rgb values
        camera_bp_rgb_car_mid = blueprint_library.find('sensor.camera.rgb')
        camera_bp_rgb_car_mid.set_attribute('image_size_x',  str(640))
        camera_bp_rgb_car_mid.set_attribute('image_size_y',  str(320))
        camera_bp_rgb_car_mid.set_attribute('fov',  str(100))
        camera_transform_rgb_car_mid = carla.Transform(
            carla.Location(x=1.5, z=2.4))
        camera_rgb_car_mid = world.spawn_actor(
            camera_bp_rgb_car_mid, camera_transform_rgb_car_mid, attach_to=vehicle)
        actor_list.append(camera_rgb_car_mid)
        print('created %s' % camera_rgb_car_mid.type_id)
        rgb_image_queue_mid = queue.Queue()
        # camera_rgb_car_mid.listen(lambda image: image.save_to_disk('_out/%s-%s/rgb-%d.png' % (map.split('/')[-1], spawn, frame)) if frame > 10 else None)
        camera_rgb_car_mid.listen(rgb_image_queue_mid.put)

        # also get and save left rgb values
        camera_bp_rgb_car_left = blueprint_library.find('sensor.camera.rgb')
        camera_bp_rgb_car_left.set_attribute('image_size_x',  str(640))
        camera_bp_rgb_car_left.set_attribute('image_size_y',  str(320))
        camera_bp_rgb_car_left.set_attribute('fov',  str(100))
        camera_transform_rgb_car_left = carla.Transform(
            carla.Location(x=1.5, y=-0.65 ,z=2.4), carla.Rotation(0, 5, 0))
        camera_rgb_car_left = world.spawn_actor(
            camera_bp_rgb_car_left, camera_transform_rgb_car_left, attach_to=vehicle)
        actor_list.append(camera_rgb_car_left)
        print('created %s' % camera_rgb_car_left.type_id)
        rgb_image_queue_left = queue.Queue()
        # camera_rgb_car.listen(lambda image: image.save_to_disk('_out/%s-%s/rgb-%d.png' % (map.split('/')[-1], spawn, frame)) if frame > 10 else None)
        camera_rgb_car_left.listen(rgb_image_queue_left.put)
        

        # also get and save right rgb values
        camera_bp_rgb_car_right = blueprint_library.find('sensor.camera.rgb')
        camera_bp_rgb_car_right.set_attribute('image_size_x',  str(640))
        camera_bp_rgb_car_right.set_attribute('image_size_y',  str(320))
        camera_bp_rgb_car_right.set_attribute('fov',  str(100))
        camera_transform_rgb_car_right = carla.Transform(
            carla.Location(x=1.5, y=0.65 ,z=2.4), carla.Rotation(0, -5, 0))
        camera_rgb_car_right = world.spawn_actor(
            camera_bp_rgb_car_right, camera_transform_rgb_car_right, attach_to=vehicle)
        actor_list.append(camera_rgb_car_right)
        print('created %s' % camera_rgb_car_right.type_id)
        rgb_image_queue_right = queue.Queue()
        # camera_rgb_car.listen(lambda image: image.save_to_disk('_out/%s-%s/rgb-%d.png' % (map.split('/')[-1], spawn, frame)) if frame > 10 else None)
        camera_rgb_car_right.listen(rgb_image_queue_right.put)

        rgb_list = list()

        # Let's add now an "RGB" camera attached to the vehicle.
        camera_bp_rgb = blueprint_library.find('sensor.camera.rgb')
        camera_bp_rgb.set_attribute('image_size_x',  str(640))
        camera_bp_rgb.set_attribute('image_size_y',  str(320))
        camera_bp_rgb.set_attribute('fov',  str(100))
        camera_transform_rgb = carla.Transform(carla.Location(x=-7.0, z=2.4))
        camera_rgb = world.spawn_actor(
            camera_bp_rgb, camera_transform_rgb, attach_to=vehicle)
        actor_list.append(camera_rgb)
        print('created %s' % camera_rgb.type_id)
        camera_rgb.listen(lambda image: rgb_list.append(
            image) if frame > 10 else None)

        

        # # But the city now is probably quite empty, let's add a few more
        # # vehicles.
        # transform.location += carla.Location(x=40, y=-3.2)
        # transform.rotation.yaw = -180.0
        # for _ in range(0, 10):
        #     transform.location.x += 8.0
        #
        #     bp = random.choice(blueprint_library.filter('vehicle'))
        #
        #     # This time we are using try_spawn_actor. If the spot is already
        #     # occupied by another object, the function will return None.
        #     npc = world.try_spawn_actor(bp, transform)
        #     if npc is not None:
        #         actor_list.append(npc)
        #         npc.set_autopilot()
        #         print('created %s' % npc.type_id)

        # init random frames 
        rand_frame = random.randint(40, 60) 

        for frame in range(300):
            # Do tick
            world.tick()
            world.get_spectator().set_transform(camera_rgb.get_transform())
            if frame == 20:
                 vehicle.set_autopilot(True)
            if frame > 50: 
                # if frame % rand_frame == 0: 
                #     print("ADD DISPLACEMENT")
                #     rand_displ = random.uniform(0.75, 1.5)
                #     print(rand_displ)
                #     location = vehicle.get_location()
                #     yaw = np.deg2rad(vehicle.get_transform().rotation.yaw)
                #     if bool(random.getrandbits(1)):
                #         location.y += np.cos(yaw) * rand_displ
                #         location.x += np.sin(yaw) * rand_displ
                #     else:
                #         location.y -= np.cos(yaw) * rand_displ
                #         location.x -= np.sin(yaw) * rand_displ
                #     vehicle.set_location(location)


                # Get synced images
                rgb_image_mid = rgb_image_queue_mid.get()
                rgb_image_left = rgb_image_queue_left.get()
                rgb_image_right = rgb_image_queue_right.get()
                depth_image = depth_image_queue.get()
                if frame % 5 == 0:
                    rgb_image_mid.save_to_disk(
                        '_out/%s-%s/%s/rgb_mid-%d.png' % (map.split('/')[-1], spawn, ts, frame))
                    rgb_image_left.save_to_disk(
                        '_out/%s-%s/%s/rgb_left-%d.png' % (map.split('/')[-1], spawn, ts, frame))
                    rgb_image_right.save_to_disk(
                        '_out/%s-%s/%s/rgb_right-%d.png' % (map.split('/')[-1], spawn, ts, frame))
                    depth_image.save_to_disk(
                        '_out/%s-%s/%s/depth-%d.png' % (map.split('/')[-1], spawn, ts, frame), cc)

            
                # visualize_image(rgb_list[-1])
                # For applying manual control. Make sure that the vehicle.set_autopilot(True) is commented out above
                # vehicle.apply_control(carla.VehicleControl(throttle=1.0, steer=0.0))
                # Always have the traffic light on green
                if vehicle.is_at_traffic_light():
                    traffic_light = vehicle.get_traffic_light()
                    if traffic_light.get_state() == carla.TrafficLightState.Red:
                        traffic_light.set_state(carla.TrafficLightState.Green)

                print('frame %s' % frame)
                print("Throttle: {}, Steering: {}".format(
                    vehicle.get_control().throttle, vehicle.get_control().steer))
                print("Vehicle location: (x,y,z): ({},{},{})".format(
                    vehicle.get_location().x, vehicle.get_location().y, vehicle.get_location().z))
                print("Vehicle transform: ", vehicle.get_transform())

                if frame % 5 == 0:
                    path = '_out/%s-%s/%s/rgb-%d.png' % (map.split('/')
                                                    [-1], spawn, ts, frame)
                    new_row = pd.DataFrame(
                        [[path, vehicle.get_control().steer, vehicle.get_control().throttle]], columns=["path", "steer", "throttle"])
                    path_to_steer = path_to_steer.append(
                        new_row, ignore_index=True)
                # pdb.set_trace()

        # time.sleep(5)

        path_to_steer.to_csv('_out/curve_to_steering.csv')
    except Exception as e:
        exc_type, exc_obj, exc_tb = sys.exc_info()
        fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
        print(exc_type, fname, exc_tb.tb_lineno)
    finally:
        try:
            print('destroying actors')
            camera.destroy()
            camera_rgb.destroy()
            camera_rgb_car_mid.destroy()
            client.apply_batch([carla.command.DestroyActor(x) for x in actor_list])
            print('done.')
        except: 
            pass


if __name__ == '__main__':
    for i in range(40):
        try:
            print("Iteration: ", i)
            main()
        except Exception as e:
            print(e)
            pass
